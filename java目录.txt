第5章 面向对象（上） 107
5.1 类和对象 108
5.1.1 定义类 108
学生提问：构造器不是没有返回值吗？为什么不能用void修饰呢？ 110
5.1.2 对象的产生和使用 110
5.1.3 对象、引用和指针 111
5.1.4 对象的this引用 112
5.2 方法详解 116
5.2.1 方法的所属性 116
5.2.2 方法的参数传递机制 116
5.2.3 形参长度可变的方法 120
5.2.4 递归方法 121
5.2.5 方法重载 123
学生提问：为什么方法的返回值类型不能用于区分重载的方法？ 124
5.3 成员变量和局部变量 124
5.3.1 成员变量和局部变量 125
5.3.2 成员变量的初始化和内存中的运行机制 128
5.3.3 局部变量的初始化和内存中的运行机制 130
5.3.4 变量的使用规则 130
5.4 隐藏和封装 132
5.4.1 理解封装 132
5.4.2 使用访问控制符 132
5.4.3 package和import 135
5.4.4 Java的常用包 140
5.5 深入构造器 140
5.5.1 使用构造器执行初始化 141
学生提问：构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？ 141
5.5.2 构造器的重载 142
学生提问：为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？ 143
5.6 类的继承 144
5.6.1 继承的特点 144
5.6.2 重写父类的方法 145
5.6.3 父类实例的super引用 146
学生提问：我们只是创建了一个Ostrich对象时，哪来的Bird对象？ 147
5.6.4 调用父类构造器 148
学生提问：为什么我创建Java对象时从未感觉到java.lang.Object的构造器被调用过？ 150
5.7 多态 151
5.7.1 多态性 151
5.7.2 引用变量的强制类型转换 152
5.7.3 instanceof运算符 154
5.8 继承与组合 154
5.8.1 使用继承的注意点 155
5.8.2 利用组合实现复用 156
学生提问：使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？ 159
5.9 初始化块 159
5.9.1 使用初始化块 160
5.9.2 初始化块和构造器 161
5.9.3 静态初始化块 162
5.10 本章小结 165
本章练习 165
第6章 面向对象（下） 166
6.1 基本数据类型的包装类 167
6.2 处理对象 170
6.2.1 打印对象和toString方法 170
6.2.2 ==和equals比较运算符 172
6.3 类成员 175
6.3.1 理解类成员 175
6.3.2 单例（Singleton）类 176
6.4 final修饰符 177
6.4.1 final变量 177
6.4.2 final方法 181
6.4.3 final类 182
6.4.4 不可变类 182
6.4.5 缓存实例的不可变类 186
6.5 抽象类 188
6.5.1 抽象方法和抽象类 188
6.5.2 抽象类的作用 191
6.6 更彻底的抽象：接口 192
6.6.1 接口的概念 192
6.6.2 接口的定义 193
6.6.3 接口的继承 195
6.6.4 使用接口 195
6.6.5 接口和抽象类 197
6.6.6 面向接口编程 198
6.7 内部类 202
6.7.1 非静态内部类 202
学生提问：非静态内部类对象和外部类对象的关系是怎样的？ 206
6.7.2 静态内部类 207
学生提问：为什么静态内部类实例方法也不能访问外部类的实例属性呢？ 207
学生提问：接口里是否能定义内部接口？ 208
6.7.3 使用内部类 208
学生提问：既然内部类是外部类的成员，是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？ 211
6.7.4 局部内部类 211
6.7.5 匿名内部类 212
6.7.6 闭包（Closure）和回调 215
6.8 枚举类 217
6.8.1 手动实现枚举类 217
6.8.2 枚举类入门 219
6.8.3 枚举类的属性、方法和构造器 220
6.8.4 实现接口的枚举类 223
6.8.5 包含抽象方法的枚举类 224
6.9 对象与垃圾回收 225
6.9.1 对象在内存中的状态 226
6.9.2 强制垃圾回收 227
6.9.3 finalize方法 228
6.9.4 对象的软、弱和虚引用 230
6.10 修饰符的适用范围 233
6.11 使用JAR文件 234
6.11.1 jar命令详解 235
6.11.2 创建可执行的JAR包 237
6.11.3 关于JAR包的技巧 238
6.12 本章小结 239
本章练习 239
第7章 Java集合 240
7.1 Java集合概述 241
7.2 Collection和Iterator接口 243
7.2.1 使用Iterator接口遍历集合元素 244
7.2.2 使用foreach循环遍历集合元素 246
7.3 Set接口 247
7.3.1 HashSet类 247
学生提问：hashCode方法对于HashSet的作用是什么？ 249
7.3.2 TreeSet类 252
7.3.3 EnumSet类 259
7.4 List接口 261
7.4.1 List接口和ListIterator接口 261
7.4.2 ArrayList和Vector实现类 264
7.4.3 固定长度的List 266
7.5 Queue接口 266
7.5.1 LinkedList实现类 266
7.5.2 PriorityQueue实现类 269
7.6 Map 270
7.6.1 HashMap和Hashtable实现类 271
7.6.2 SortedMap接口和TreeMap实现类 276
7.6.3 WeakHashMap实现类 279
7.6.4 IdentityHashMap实现类 280
7.6.5 EnumMap实现类 281
7.7 HashSet和HashMap的性能选项 282
7.8 操作集合的工具类：Collections 283
7.8.1 排序操作 283
7.8.2 查找，替换操作 287
7.8.3 同步控制 288
7.8.4 设置不可变集合 288
7.9 烦琐的接口：Enumeration 289
7.10 本章小结 290
本章练习 290
第8章 泛型 291
8.1 泛型入门 292
8.1.1 编译时不检查类型的异常 292
8.1.2 手动实现编译时检查类型 293
8.1.3 使用泛型 294
8.2 深入泛型 294
8.2.1 定义泛型接口、类 295
8.2.2 从泛型类派生子类 296
8.2.3 并不存在泛型类 298
8.3 类型通配符 298
8.3.1 使用类型通配符 300
8.3.2 设定类型通配符的上限 300
8.3.3 设定类型形参的上限 302
8.4 泛型方法 303
8.4.1 定义泛型方法 303
8.4.2 泛型方法和类型通配符的区别 306
8.4.3 设定通配符的下限 307
8.4.4 泛型方法与方法重载 309
8.5 擦除和转换 310
8.6 泛型与数组 311
8.7 本章小结 313
第9章 与运行环境交互 314
9.1 与用户互动 315
9.1.1 运行Java程序的参数 315
9.1.2 使用Scanner获取键盘输入 316
9.1.3 使用BufferedReader获取键盘输入 318
9.2 系统相关 319
9.2.1 System类 319
9.2.2 Runtime类 321
9.3 常用类 322
9.3.1 Object类 322
9.3.2 String、StringBuffer和StringBuilder类 322
9.3.3 Math类 327
9.3.4 Random类 328
9.3.5 BigDecimal类 330
9.4 处理日期的类 333
9.4.1 Date类 333
9.4.2 Calendar类 334
9.4.3 TimeZone类 337
9.5 正则表达式 338
9.5.1 创建正则表达式 338
9.5.2 使用正则表达式 341
9.6 程序国际化 345
9.6.1 Java国际化的思路 346
9.6.2 Java支持的语言和国家 346
9.6.3 完成程序国际化 347
9.6.4 使用MessageFormat处理包含占位符的字符串 349
9.6.5 使用类文件代替资源文件 350
9.6.6 使用NumberFormat格式化数字 350
9.6.7 使用DateFormat格式化日期 352
9.7 本章小结 355
本章练习 355
第10章 异常处理 356
10.1 异常概述 357
10.2 异常处理机制 358
10.2.1 使用try...catch捕获异常 359
10.2.2 异常类的继承体系 360
10.2.3 访问异常信息 363
10.2.4 使用finally回收资源 364
10.2.5 异常处理的嵌套 367
10.3 Checked异常和Runtime异常体系 367
10.3.1 使用throws声明抛出异常 367
10.4 使用throw抛出异常 369
10.4.1 抛出异常 369
10.4.2 自定义异常类 371
10.4.3 catch和throw同时使用 371
10.4.4 异常链 373
10.5 Java的异常跟踪栈 374
10.6 异常处理规则 376
10.6.1 不要过度使用异常 377
10.6.2 不要使用过于庞大的try块 378
10.6.3 避免使用Catch All语句 378
10.6.4 不要忽略捕获到的异常 379
10.7 本章小结 379
本章练习 379